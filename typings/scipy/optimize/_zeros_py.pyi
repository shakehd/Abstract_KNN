from ._optimize import OptimizeResult
from _typeshed import Incomplete

class RootResults(OptimizeResult):
    root: Incomplete
    iterations: Incomplete
    function_calls: Incomplete
    converged: Incomplete
    flag: Incomplete
    def __init__(self, root, iterations, function_calls, flag) -> None: ...

def newton(func, x0, fprime: Incomplete | None = ..., args=..., tol: float = ..., maxiter: int = ..., fprime2: Incomplete | None = ..., x1: Incomplete | None = ..., rtol: float = ..., full_output: bool = ..., disp: bool = ...): ...
def bisect(f, a, b, args=..., xtol=..., rtol=..., maxiter=..., full_output: bool = ..., disp: bool = ...): ...
def ridder(f, a, b, args=..., xtol=..., rtol=..., maxiter=..., full_output: bool = ..., disp: bool = ...): ...
def brentq(f, a, b, args=..., xtol=..., rtol=..., maxiter=..., full_output: bool = ..., disp: bool = ...): ...
def brenth(f, a, b, args=..., xtol=..., rtol=..., maxiter=..., full_output: bool = ..., disp: bool = ...): ...

class TOMS748Solver:
    f: Incomplete
    args: Incomplete
    function_calls: int
    iterations: int
    k: int
    ab: Incomplete
    fab: Incomplete
    d: Incomplete
    fd: Incomplete
    e: Incomplete
    fe: Incomplete
    disp: bool
    xtol: Incomplete
    rtol: Incomplete
    maxiter: Incomplete
    def __init__(self) -> None: ...
    def configure(self, xtol, rtol, maxiter, disp, k) -> None: ...
    def get_result(self, x, flag=...): ...
    def start(self, f, a, b, args=...): ...
    def get_status(self): ...
    def iterate(self): ...
    def solve(self, f, a, b, args=..., xtol=..., rtol=..., k: int = ..., maxiter=..., disp: bool = ...): ...

def toms748(f, a, b, args=..., k: int = ..., xtol=..., rtol=..., maxiter=..., full_output: bool = ..., disp: bool = ...): ...
