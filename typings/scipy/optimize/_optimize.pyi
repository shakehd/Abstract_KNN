from ._linesearch import line_search_wolfe2 as line_search
from _typeshed import Incomplete

class MemoizeJac:
    fun: Incomplete
    jac: Incomplete
    x: Incomplete
    def __init__(self, fun) -> None: ...
    def __call__(self, x, *args): ...
    def derivative(self, x, *args): ...

class OptimizeResult(dict):
    def __getattr__(self, name): ...
    __setattr__: Incomplete
    __delattr__: Incomplete
    def __dir__(self): ...

class OptimizeWarning(UserWarning): ...

def rosen(x): ...
def rosen_der(x): ...
def rosen_hess(x): ...
def rosen_hess_prod(x, p): ...

class _MaxFuncCallError(RuntimeError): ...

def fmin(func, x0, args=..., xtol: float = ..., ftol: float = ..., maxiter: Incomplete | None = ..., maxfun: Incomplete | None = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Incomplete | None = ..., initial_simplex: Incomplete | None = ...): ...
def approx_fprime(xk, f, epsilon=..., *args): ...
def check_grad(func, grad, x0, *args, epsilon=..., direction: str = ..., seed: Incomplete | None = ...): ...

class _LineSearchError(RuntimeError): ...

def fmin_bfgs(f, x0, fprime: Incomplete | None = ..., args=..., gtol: float = ..., norm=..., epsilon=..., maxiter: Incomplete | None = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Incomplete | None = ..., xrtol: int = ...): ...
def fmin_cg(f, x0, fprime: Incomplete | None = ..., args=..., gtol: float = ..., norm=..., epsilon=..., maxiter: Incomplete | None = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Incomplete | None = ...): ...
def fmin_ncg(f, x0, fprime, fhess_p: Incomplete | None = ..., fhess: Incomplete | None = ..., args=..., avextol: float = ..., epsilon=..., maxiter: Incomplete | None = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Incomplete | None = ...): ...
def fminbound(func, x1, x2, args=..., xtol: float = ..., maxfun: int = ..., full_output: int = ..., disp: int = ...): ...

class Brent:
    func: Incomplete
    args: Incomplete
    tol: Incomplete
    maxiter: Incomplete
    xmin: Incomplete
    fval: Incomplete
    iter: int
    funcalls: int
    disp: Incomplete
    def __init__(self, func, args=..., tol: float = ..., maxiter: int = ..., full_output: int = ..., disp: int = ...) -> None: ...
    brack: Incomplete
    def set_bracket(self, brack: Incomplete | None = ...) -> None: ...
    def get_bracket_info(self): ...
    def optimize(self) -> None: ...
    def get_result(self, full_output: bool = ...): ...

def brent(func, args=..., brack: Incomplete | None = ..., tol: float = ..., full_output: int = ..., maxiter: int = ...): ...
def golden(func, args=..., brack: Incomplete | None = ..., tol=..., full_output: int = ..., maxiter: int = ...): ...
def bracket(func, xa: float = ..., xb: float = ..., args=..., grow_limit: float = ..., maxiter: int = ...): ...

class BracketError(RuntimeError): ...

def fmin_powell(func, x0, args=..., xtol: float = ..., ftol: float = ..., maxiter: Incomplete | None = ..., maxfun: Incomplete | None = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Incomplete | None = ..., direc: Incomplete | None = ...): ...
def brute(func, ranges, args=..., Ns: int = ..., full_output: int = ..., finish=..., disp: bool = ..., workers: int = ...): ...

class _Brute_Wrapper:
    f: Incomplete
    args: Incomplete
    def __init__(self, f, args) -> None: ...
    def __call__(self, x): ...

def show_options(solver: Incomplete | None = ..., method: Incomplete | None = ..., disp: bool = ...): ...
