from ._stats_mstats_common import linregress as linregress, siegelslopes as siegelslopes, theilslopes as theilslopes
from _typeshed import Incomplete
from dataclasses import dataclass
from typing import NamedTuple

def gmean(a, axis: int = ..., dtype: Incomplete | None = ..., weights: Incomplete | None = ...): ...
def hmean(a, axis: int = ..., dtype: Incomplete | None = ..., *, weights: Incomplete | None = ...): ...
def pmean(a, p, *, axis: int = ..., dtype: Incomplete | None = ..., weights: Incomplete | None = ...): ...

class ModeResult(NamedTuple):
    mode: Incomplete
    count: Incomplete

def mode(a, axis: int = ..., nan_policy: str = ..., keepdims: bool = ...): ...
def tmean(a, limits: Incomplete | None = ..., inclusive=..., axis: Incomplete | None = ...): ...
def tvar(a, limits: Incomplete | None = ..., inclusive=..., axis: int = ..., ddof: int = ...): ...
def tmin(a, lowerlimit: Incomplete | None = ..., axis: int = ..., inclusive: bool = ..., nan_policy: str = ...): ...
def tmax(a, upperlimit: Incomplete | None = ..., axis: int = ..., inclusive: bool = ..., nan_policy: str = ...): ...
def tstd(a, limits: Incomplete | None = ..., inclusive=..., axis: int = ..., ddof: int = ...): ...
def tsem(a, limits: Incomplete | None = ..., inclusive=..., axis: int = ..., ddof: int = ...): ...
def moment(a, moment: int = ..., axis: int = ..., nan_policy: str = ..., *, center: Incomplete | None = ...): ...
def skew(a, axis: int = ..., bias: bool = ..., nan_policy: str = ...): ...
def kurtosis(a, axis: int = ..., fisher: bool = ..., bias: bool = ..., nan_policy: str = ...): ...

class DescribeResult(NamedTuple):
    nobs: Incomplete
    minmax: Incomplete
    mean: Incomplete
    variance: Incomplete
    skewness: Incomplete
    kurtosis: Incomplete

def describe(a, axis: int = ..., ddof: int = ..., bias: bool = ..., nan_policy: str = ...): ...

class SkewtestResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def skewtest(a, axis: int = ..., nan_policy: str = ..., alternative: str = ...): ...

class KurtosistestResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def kurtosistest(a, axis: int = ..., nan_policy: str = ..., alternative: str = ...): ...

class NormaltestResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def normaltest(a, axis: int = ..., nan_policy: str = ...): ...
def jarque_bera(x, *, axis: Incomplete | None = ...): ...
def scoreatpercentile(a, per, limit=..., interpolation_method: str = ..., axis: Incomplete | None = ...): ...
def percentileofscore(a, score, kind: str = ..., nan_policy: str = ...): ...

class HistogramResult(NamedTuple):
    count: Incomplete
    lowerlimit: Incomplete
    binsize: Incomplete
    extrapoints: Incomplete

class CumfreqResult(NamedTuple):
    cumcount: Incomplete
    lowerlimit: Incomplete
    binsize: Incomplete
    extrapoints: Incomplete

def cumfreq(a, numbins: int = ..., defaultreallimits: Incomplete | None = ..., weights: Incomplete | None = ...): ...

class RelfreqResult(NamedTuple):
    frequency: Incomplete
    lowerlimit: Incomplete
    binsize: Incomplete
    extrapoints: Incomplete

def relfreq(a, numbins: int = ..., defaultreallimits: Incomplete | None = ..., weights: Incomplete | None = ...): ...
def obrientransform(*samples): ...
def sem(a, axis: int = ..., ddof: int = ..., nan_policy: str = ...): ...
def zscore(a, axis: int = ..., ddof: int = ..., nan_policy: str = ...): ...
def gzscore(a, *, axis: int = ..., ddof: int = ..., nan_policy: str = ...): ...
def zmap(scores, compare, axis: int = ..., ddof: int = ..., nan_policy: str = ...): ...
def gstd(a, axis: int = ..., ddof: int = ...): ...
def iqr(x, axis: Incomplete | None = ..., rng=..., scale: float = ..., nan_policy: str = ..., interpolation: str = ..., keepdims: bool = ...): ...
def median_abs_deviation(x, axis: int = ..., center=..., scale: float = ..., nan_policy: str = ...): ...

class SigmaclipResult(NamedTuple):
    clipped: Incomplete
    lower: Incomplete
    upper: Incomplete

def sigmaclip(a, low: float = ..., high: float = ...): ...
def trimboth(a, proportiontocut, axis: int = ...): ...
def trim1(a, proportiontocut, tail: str = ..., axis: int = ...): ...
def trim_mean(a, proportiontocut, axis: int = ...): ...

class F_onewayResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def f_oneway(*samples, axis: int = ...): ...
def alexandergovern(*samples, nan_policy: str = ...): ...

@dataclass
class AlexanderGovernResult:
    statistic: float
    pvalue: float
    def __init__(self, statistic, pvalue) -> None: ...

class ConfidenceInterval(NamedTuple):
    low: Incomplete
    high: Incomplete

class PearsonRResult(PearsonRResultBase):
    correlation: Incomplete
    def __init__(self, statistic, pvalue, alternative, n, x, y) -> None: ...
    def confidence_interval(self, confidence_level: float = ..., method: Incomplete | None = ...): ...

def pearsonr(x, y, *, alternative: str = ..., method: Incomplete | None = ...): ...
def fisher_exact(table, alternative: str = ...): ...
def spearmanr(a, b: Incomplete | None = ..., axis: int = ..., nan_policy: str = ..., alternative: str = ...): ...
def pointbiserialr(x, y): ...
def kendalltau(x, y, initial_lexsort: Incomplete | None = ..., nan_policy: str = ..., method: str = ..., variant: str = ..., alternative: str = ...): ...
def weightedtau(x, y, rank: bool = ..., weigher: Incomplete | None = ..., additive: bool = ...): ...

class _ParallelP:
    x: Incomplete
    y: Incomplete
    random_states: Incomplete
    def __init__(self, x, y, random_states) -> None: ...
    def __call__(self, index): ...

def multiscale_graphcorr(x, y, compute_distance=..., reps: int = ..., workers: int = ..., is_twosamp: bool = ..., random_state: Incomplete | None = ...): ...

class TtestResult(TtestResultBase):
    def __init__(self, statistic, pvalue, df, alternative, standard_error, estimate) -> None: ...
    def confidence_interval(self, confidence_level: float = ...): ...

def ttest_1samp(a, popmean, axis: int = ..., nan_policy: str = ..., alternative: str = ...): ...

class Ttest_indResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def ttest_ind_from_stats(mean1, std1, nobs1, mean2, std2, nobs2, equal_var: bool = ..., alternative: str = ...): ...
def ttest_ind(a, b, axis: int = ..., equal_var: bool = ..., nan_policy: str = ..., permutations: Incomplete | None = ..., random_state: Incomplete | None = ..., alternative: str = ..., trim: int = ...): ...
def ttest_rel(a, b, axis: int = ..., nan_policy: str = ..., alternative: str = ...): ...

class Power_divergenceResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def power_divergence(f_obs, f_exp: Incomplete | None = ..., ddof: int = ..., axis: int = ..., lambda_: Incomplete | None = ...): ...
def chisquare(f_obs, f_exp: Incomplete | None = ..., ddof: int = ..., axis: int = ...): ...
def ks_1samp(x, cdf, args=..., alternative: str = ..., method: str = ...): ...
Ks_2sampResult = KstestResult

def ks_2samp(data1, data2, alternative: str = ..., method: str = ...): ...
def kstest(rvs, cdf, args=..., N: int = ..., alternative: str = ..., method: str = ...): ...
def tiecorrect(rankvals): ...

class RanksumsResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def ranksums(x, y, alternative: str = ...): ...

class KruskalResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def kruskal(*samples, nan_policy: str = ...): ...

class FriedmanchisquareResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def friedmanchisquare(*samples): ...

class BrunnerMunzelResult(NamedTuple):
    statistic: Incomplete
    pvalue: Incomplete

def brunnermunzel(x, y, alternative: str = ..., distribution: str = ..., nan_policy: str = ...): ...
def combine_pvalues(pvalues, method: str = ..., weights: Incomplete | None = ...): ...
def wasserstein_distance(u_values, v_values, u_weights: Incomplete | None = ..., v_weights: Incomplete | None = ...): ...
def energy_distance(u_values, v_values, u_weights: Incomplete | None = ..., v_weights: Incomplete | None = ...): ...

class RepeatedResults(NamedTuple):
    values: Incomplete
    counts: Incomplete

def find_repeats(arr): ...
def rankdata(a, method: str = ..., *, axis: Incomplete | None = ..., nan_policy: str = ...): ...
def expectile(a, alpha: float = ..., *, weights: Incomplete | None = ...): ...
