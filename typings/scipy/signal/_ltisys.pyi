from _typeshed import Incomplete

class LinearTimeInvariant:
    def __new__(cls, *system, **kwargs): ...
    inputs: Incomplete
    outputs: Incomplete
    def __init__(self) -> None: ...
    @property
    def dt(self): ...
    @property
    def zeros(self): ...
    @property
    def poles(self): ...

class lti(LinearTimeInvariant):
    def __new__(cls, *system): ...
    def __init__(self, *system) -> None: ...
    def impulse(self, X0: Incomplete | None = ..., T: Incomplete | None = ..., N: Incomplete | None = ...): ...
    def step(self, X0: Incomplete | None = ..., T: Incomplete | None = ..., N: Incomplete | None = ...): ...
    def output(self, U, T, X0: Incomplete | None = ...): ...
    def bode(self, w: Incomplete | None = ..., n: int = ...): ...
    def freqresp(self, w: Incomplete | None = ..., n: int = ...): ...
    def to_discrete(self, dt, method: str = ..., alpha: Incomplete | None = ...) -> None: ...

class dlti(LinearTimeInvariant):
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    @property
    def dt(self): ...
    @dt.setter
    def dt(self, dt) -> None: ...
    def impulse(self, x0: Incomplete | None = ..., t: Incomplete | None = ..., n: Incomplete | None = ...): ...
    def step(self, x0: Incomplete | None = ..., t: Incomplete | None = ..., n: Incomplete | None = ...): ...
    def output(self, u, t, x0: Incomplete | None = ...): ...
    def bode(self, w: Incomplete | None = ..., n: int = ...): ...
    def freqresp(self, w: Incomplete | None = ..., n: int = ..., whole: bool = ...): ...

class TransferFunction(LinearTimeInvariant):
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    @property
    def num(self): ...
    outputs: int
    inputs: int
    @num.setter
    def num(self, num) -> None: ...
    @property
    def den(self): ...
    @den.setter
    def den(self, den) -> None: ...
    def to_tf(self): ...
    def to_zpk(self): ...
    def to_ss(self): ...

class TransferFunctionContinuous(TransferFunction, lti):
    def to_discrete(self, dt, method: str = ..., alpha: Incomplete | None = ...): ...

class TransferFunctionDiscrete(TransferFunction, dlti): ...

class ZerosPolesGain(LinearTimeInvariant):
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    @property
    def zeros(self): ...
    outputs: int
    inputs: int
    @zeros.setter
    def zeros(self, zeros) -> None: ...
    @property
    def poles(self): ...
    @poles.setter
    def poles(self, poles) -> None: ...
    @property
    def gain(self): ...
    @gain.setter
    def gain(self, gain) -> None: ...
    def to_tf(self): ...
    def to_zpk(self): ...
    def to_ss(self): ...

class ZerosPolesGainContinuous(ZerosPolesGain, lti):
    def to_discrete(self, dt, method: str = ..., alpha: Incomplete | None = ...): ...

class ZerosPolesGainDiscrete(ZerosPolesGain, dlti): ...

class StateSpace(LinearTimeInvariant):
    __array_priority__: float
    __array_ufunc__: Incomplete
    def __new__(cls, *system, **kwargs): ...
    def __init__(self, *system, **kwargs) -> None: ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __neg__(self): ...
    def __add__(self, other): ...
    def __sub__(self, other): ...
    def __radd__(self, other): ...
    def __rsub__(self, other): ...
    def __truediv__(self, other): ...
    @property
    def A(self): ...
    @A.setter
    def A(self, A) -> None: ...
    @property
    def B(self): ...
    inputs: Incomplete
    @B.setter
    def B(self, B) -> None: ...
    @property
    def C(self): ...
    outputs: Incomplete
    @C.setter
    def C(self, C) -> None: ...
    @property
    def D(self): ...
    @D.setter
    def D(self, D) -> None: ...
    def to_tf(self, **kwargs): ...
    def to_zpk(self, **kwargs): ...
    def to_ss(self): ...

class StateSpaceContinuous(StateSpace, lti):
    def to_discrete(self, dt, method: str = ..., alpha: Incomplete | None = ...): ...

class StateSpaceDiscrete(StateSpace, dlti): ...

def lsim2(system, U: Incomplete | None = ..., T: Incomplete | None = ..., X0: Incomplete | None = ..., **kwargs): ...
def lsim(system, U, T, X0: Incomplete | None = ..., interp: bool = ...): ...
def impulse(system, X0: Incomplete | None = ..., T: Incomplete | None = ..., N: Incomplete | None = ...): ...
def impulse2(system, X0: Incomplete | None = ..., T: Incomplete | None = ..., N: Incomplete | None = ..., **kwargs): ...
def step(system, X0: Incomplete | None = ..., T: Incomplete | None = ..., N: Incomplete | None = ...): ...
def step2(system, X0: Incomplete | None = ..., T: Incomplete | None = ..., N: Incomplete | None = ..., **kwargs): ...
def bode(system, w: Incomplete | None = ..., n: int = ...): ...
def freqresp(system, w: Incomplete | None = ..., n: int = ...): ...

class Bunch:
    def __init__(self, **kwds) -> None: ...

def place_poles(A, B, poles, method: str = ..., rtol: float = ..., maxiter: int = ...): ...
def dlsim(system, u, t: Incomplete | None = ..., x0: Incomplete | None = ...): ...
def dimpulse(system, x0: Incomplete | None = ..., t: Incomplete | None = ..., n: Incomplete | None = ...): ...
def dstep(system, x0: Incomplete | None = ..., t: Incomplete | None = ..., n: Incomplete | None = ...): ...
def dfreqresp(system, w: Incomplete | None = ..., n: int = ..., whole: bool = ...): ...
def dbode(system, w: Incomplete | None = ..., n: int = ...): ...
