import typing
from ._uarray import BackendNotImplementedError as BackendNotImplementedError, _BackendState as _BackendState, _Function as _Function, _SetBackendContext as _SetBackendContext, _SkipBackendContext as _SkipBackendContext
from _typeshed import Incomplete
from collections.abc import Generator

def get_state(): ...
def reset_state() -> Generator[None, None, None]: ...
def set_state(state) -> Generator[None, None, None]: ...
def create_multimethod(*args, **kwargs): ...
def generate_multimethod(argument_extractor: ArgumentExtractorType, argument_replacer: ArgumentReplacerType, domain: str, default: typing.Optional[typing.Callable] = ...): ...
def set_backend(backend, coerce: bool = ..., only: bool = ...): ...
def skip_backend(backend): ...
def set_global_backend(backend, coerce: bool = ..., only: bool = ..., *, try_last: bool = ...) -> None: ...
def register_backend(backend) -> None: ...
def clear_backends(domain, registered: bool = ..., globals: bool = ...) -> None: ...

class Dispatchable:
    value: Incomplete
    type: Incomplete
    coercible: Incomplete
    def __init__(self, value, dispatch_type, coercible: bool = ...) -> None: ...
    def __getitem__(self, index): ...

def mark_as(dispatch_type): ...
def all_of_type(arg_type): ...
def wrap_single_convertor(convert_single): ...
def wrap_single_convertor_instance(convert_single): ...
def determine_backend(value, dispatch_type, *, domain, only: bool = ..., coerce: bool = ...): ...
def determine_backend_multi(dispatchables, *, domain, only: bool = ..., coerce: bool = ..., **kwargs): ...
